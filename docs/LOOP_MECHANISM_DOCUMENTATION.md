# Looper - Loop Mechanism Documentation

## Overview

This document provides a comprehensive explanation of how the looping mechanism works in the Looper application. This is essential documentation for understanding, maintaining, and troubleshooting the video looping functionality.

## Table of Contents

1. [Core Concept](#core-concept)
2. [Technical Implementation](#technical-implementation)
3. [FFmpeg Filter Complex Breakdown](#ffmpeg-filter-complex-breakdown)
4. [Processing Pipeline](#processing-pipeline)
5. [Fallback Mechanisms](#fallback-mechanisms)
6. [Troubleshooting Guide](#troubleshooting-guide)
7. [Code References](#code-references)

## Core Concept

The Looper application creates "perfect loops" using a VJ technique that eliminates the jarring "jump cut" that occurs when a video loops back to its beginning. Instead of a hard cut, it creates a seamless crossfade transition.

### The Problem
When a regular video loops, there's an abrupt transition from the last frame back to the first frame, creating a visible "jump" that breaks the illusion of continuous motion.

### The Solution
The Looper uses a crossfade technique that:
1. **Duplicates** the video clip
2. **Overlaps** the end of the first clip with the beginning of the second
3. **Applies a crossfade** transition during the overlap period
4. **Outputs only the original duration** (no extra runtime)

## Technical Implementation

### Key Components

#### 1. Video Analysis (`analyze_all_videos()`)
- Uses OpenCV to extract video properties:
  - Frame rate (FPS)
  - Total frame count
  - Duration
  - Resolution
  - File size

#### 2. Overlap Calculation
The overlap can be specified in two modes:
- **Seconds mode**: User specifies overlap duration (e.g., 1.0 seconds)
- **Frames mode**: User specifies overlap in frames (e.g., 30 frames)

```python
# Calculate overlap frames based on mode
if self.overlap_mode.get() == "seconds":
    overlap_frames = int(overlap_time * video_info['fps'])
else:
    overlap_frames = int(overlap_time)
```

#### 3. Filter Complex Generation (`build_filter_complex()`)
This is the heart of the looping mechanism. It generates an FFmpeg filter complex that creates the perfect loop.

## FFmpeg Filter Complex Breakdown

The core filter complex is generated by the `build_filter_complex()` method:

```python
# Calculate fade duration (shortened by 1 frame for precision)
frame_duration = 1.0 / fps
fade_duration = overlap_duration - frame_duration

filter_str = f"[0:v]fps={fps},trim=0:{output_duration},setpts=PTS-STARTPTS[base];[0:v]fps={fps},trim={trim_start}:{total_duration},setpts=PTS-STARTPTS,fade=t=out:st=0:d={fade_duration}:alpha=1:color=black[overlay];[base][overlay]overlay,format=yuv420p[outv]"
```

### Step-by-Step Breakdown

#### Step 1: Create Base Video Stream
```
[0:v]fps={fps},trim=0:{output_duration},setpts=PTS-STARTPTS[base]
```
- Takes the input video `[0:v]`
- **FIX: Forces exact frame alignment** with `fps={fps}` to handle variable framerates
- Trims it from start (0) to `output_duration` (original duration minus overlap)
- Resets presentation timestamps with `setpts=PTS-STARTPTS`
- Outputs to label `[base]`

#### Step 2: Create Overlay Stream
```
[0:v]fps={fps},trim={trim_start}:{total_duration},setpts=PTS-STARTPTS,fade=t=out:st=0:d={fade_duration}:alpha=1:color=black[overlay]
```
- Takes the same input video `[0:v]`
- **FIX: Forces exact frame alignment** with `fps={fps}` to handle variable framerates
- Trims from `trim_start` (end minus overlap) to `total_duration` (end)
- Resets presentation timestamps
- **FIX: Applies fade-out with precision fixes**:
  - Duration is `fade_duration` (overlap_duration minus 1 frame)
  - `alpha=1` enables alpha channel processing
  - `color=black` ensures fade goes to true black/transparency
- Outputs to label `[overlay]`

#### Step 3: Composite the Streams
```
[base][overlay]overlay,format=yuv420p[outv]
```
- Takes the `[base]` and `[overlay]` streams
- Overlays them using FFmpeg's overlay filter
- **FIX: Ensures proper color format** with `format=yuv420p`
- Outputs the final result to `[outv]`

### Mathematical Relationships

```python
# Calculate the correct durations
trim_start = total_duration - overlap_duration  # Start X seconds before end
output_duration = total_duration - overlap_duration  # Shorter final length

# FIX: Calculate fade duration with precision handling
frame_duration = 1.0 / fps
fade_duration = overlap_duration - frame_duration  # Shorten by 1 frame
```

**Example with 10-second video, 1-second overlap, and 24fps:**
- `total_duration = 10.0` seconds
- `overlap_duration = 1.0` seconds
- `frame_duration = 1.0 / 24 = 0.041667` seconds
- `fade_duration = 1.0 - 0.041667 = 0.958333` seconds
- `trim_start = 9.0` seconds (start overlay at 9 seconds)
- `output_duration = 9.0` seconds (final video is 9 seconds long)

## Processing Pipeline

### 1. Primary Method: Complex Filter (`try_complex_filter_for_file()`)

```python
ffmpeg_cmd = [
    'ffmpeg', '-y',  # Overwrite output
    '-i', input_path,  # Input video
    '-filter_complex', self.build_filter_complex(overlap_frames, total_frames, fps),
    '-map', '[outv]',  # Map the output from filter complex
    '-c:v', self.get_codec(output_format),
    '-preset', 'fast',
    '-crf', self.get_crf_value(output_format),
    '-pix_fmt', 'yuv420p',  # Ensure compatibility with H.264
    output_path
]
```

### 2. Fallback Method 1: Simple Loop (`try_simple_loop_for_file()`)

If the complex filter fails, it falls back to a simple loop:

```python
ffmpeg_cmd = [
    'ffmpeg', '-y',
    '-i', input_path,
    '-filter_complex', f'[0:v]loop=loop=1:size=1,trim=duration={duration*2}[outv]',
    '-map', '[outv]',
    '-c:v', self.get_codec(output_format),
    '-preset', 'fast',
    '-crf', self.get_crf_value(output_format),
    '-pix_fmt', 'yuv420p',
    output_path
]
```

### 3. Fallback Method 2: Basic Copy (`try_basic_copy_for_file()`)

If all else fails, it simply copies the video:

```python
ffmpeg_cmd = [
    'ffmpeg', '-y',
    '-i', input_path,
    '-c:v', self.get_codec(output_format),
    '-preset', 'fast',
    '-crf', '18',
    '-pix_fmt', 'yuv420p',
    output_path
]
```

## Fallback Mechanisms

The application implements a three-tier fallback system:

1. **Complex Filter** (Primary): Creates perfect crossfade loops
2. **Simple Loop** (Fallback 1): Creates basic loops without crossfade
3. **Basic Copy** (Fallback 2): Ensures the video is at least saved in the desired format

This ensures that even if the advanced looping fails, the user still gets a processed video.

## Precision Fixes for Variable Framerate Issues

### Problem: Residual Fade Frames
With non-standard framerates (like 24.001593 fps), the fade-out effect can leave residual frames visible due to:
- Timing precision issues
- Alpha channel processing inconsistencies
- Frame boundary misalignment

### Solution: Three-Point Precision Fix

#### 1. Force Exact Frame Alignment
```python
fps={fps}  # Applied before trim operations
```
- Stabilizes variable framerates to exact frame steps
- Ensures consistent timing calculations
- Prevents frame boundary misalignment

#### 2. Clamp Fade Fully to Zero
```python
fade=t=out:st=0:d={fade_duration}:alpha=1:color=black
```
- `alpha=1`: Enables proper alpha channel processing
- `color=black`: Ensures fade reaches true black/transparency
- Prevents residual alpha values from remaining visible

#### 3. Shorten Fade by One Frame
```python
frame_duration = 1.0 / fps
fade_duration = overlap_duration - frame_duration
```
- Ensures fade completes before the overlay segment ends
- Provides buffer against timing precision issues
- Guarantees no residual frames remain

#### 4. Ensure Proper Color Format
```python
format=yuv420p  # Applied at the end of the filter chain
```
- Ensures consistent color format output
- Prevents color space conversion issues
- Maintains compatibility across different codecs

### Implementation Example
```python
def build_filter_complex(self, overlap_frames, total_frames, fps=30):
    # Calculate durations
    overlap_duration = overlap_frames / fps
    total_duration = total_frames / fps
    trim_start = total_duration - overlap_duration
    output_duration = total_duration - overlap_duration
    
    # Precision fix: shorten fade by 1 frame
    frame_duration = 1.0 / fps
    fade_duration = overlap_duration - frame_duration
    
    # Apply all precision fixes
    filter_str = f"[0:v]fps={fps},trim=0:{output_duration},setpts=PTS-STARTPTS[base];[0:v]fps={fps},trim={trim_start}:{total_duration},setpts=PTS-STARTPTS,fade=t=out:st=0:d={fade_duration}:alpha=1:color=black[overlay];[base][overlay]overlay,format=yuv420p[outv]"
    
    return filter_str
```

## Troubleshooting Guide

### Common Issues and Solutions

#### 1. Complex Filter Fails
**Symptoms:**
- Error messages in console about filter complex
- Video processing stops at complex filter stage

**Solutions:**
- Check FFmpeg version (requires FFmpeg 4.0+)
- Verify video format compatibility
- Try reducing overlap duration
- Check available system memory

#### 2. Overlap Duration Issues
**Symptoms:**
- "Overlap exceeds video duration" errors
- Unexpected video lengths

**Solutions:**
- The system automatically limits overlap to 10% of video duration
- Check video duration is longer than desired overlap
- Verify FPS calculation is correct

#### 3. Codec Compatibility
**Symptoms:**
- Encoding errors
- Unsupported format errors

**Solutions:**
- HAP format requires FFmpeg with HAP support
- MP4 format uses libx264 codec
- Ensure `yuv420p` pixel format for compatibility

#### 4. Residual Fade Frames (Variable Framerate Issues)
**Symptoms:**
- Very faint residual frame visible after fade-out completes
- Issue occurs with non-standard framerates (e.g., 24.001593 fps)
- Fade appears to not reach complete transparency

**Solutions:**
- Apply the three-point precision fix:
  1. Use `fps={fps}` filter before trim operations
  2. Add `:color=black` to fade filter parameters
  3. Shorten fade duration by 1 frame: `fade_duration = overlap_duration - (1/fps)`
  4. Add `format=yuv420p` at the end of filter chain
- This ensures exact frame alignment and complete fade-out

### Debug Information

The application provides extensive debug output:

```python
print("=" * 60)
print("DEBUGGING LOOP FILTER:")
print("Input path:", input_path)
print("Output path:", output_path)
print("Overlap frames:", overlap_frames)
print("Total frames:", total_frames)
print("FPS:", fps)
print("Filter complex:")
print(self.build_filter_complex(overlap_frames, total_frames, fps))
print("FFmpeg command:", ' '.join(ffmpeg_cmd))
print("=" * 60)
```

## Code References

### Key Methods

1. **`build_filter_complex()`** (Lines 1666-1707)
   - Generates the FFmpeg filter complex
   - Calculates timing and overlap parameters
   - Implements precision fixes for variable framerate issues

2. **`try_complex_filter_for_file()`** (Lines 1868-1943)
   - Executes the primary looping method
   - Handles progress tracking and error reporting

3. **`process_single_video()`** (Lines 1630-1664)
   - Orchestrates the three-tier fallback system
   - Manages the processing pipeline

4. **`analyze_all_videos()`** (Lines 1354-1393)
   - Extracts video metadata using OpenCV
   - Provides essential timing information

### Configuration Variables

- `overlap_var`: User-specified overlap duration
- `overlap_mode`: "seconds" or "frames" mode
- `format_var`: Output format ("HAP" or "MP4")
- `quality_var`: CRF quality setting for MP4

## Visual Representation

```
Original Video: [====10 seconds====]
                    ↑
                    │
                    │ Overlap (1 second)
                    │
Overlay Stream:     [====1 second====] (fades out)
Base Stream:    [====9 seconds====]
                    ↑
                    │
                    │ Overlay
                    │
Final Output:   [====9 seconds====] (seamless loop)
```

When the final video loops, the crossfade creates a smooth transition from the end back to the beginning, eliminating the jump cut effect.

## Dependencies

### Required Software
- **FFmpeg**: Video processing engine
- **OpenCV**: Video analysis and metadata extraction
- **Python 3.7+**: Runtime environment

### Python Packages
- `opencv-python`: Video analysis
- `Pillow`: Image processing
- `numpy`: Numerical operations
- `tkinter`: GUI framework

## Conclusion

The Looper's looping mechanism is a sophisticated system that combines video analysis, mathematical calculations, and FFmpeg's powerful filtering capabilities to create seamless video loops. The three-tier fallback system ensures reliability, while the detailed debug output aids in troubleshooting.

This documentation should provide everything needed to understand, maintain, and troubleshoot the looping functionality in the Looper application.
